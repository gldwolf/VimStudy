# Vim 学习笔记
### 在命令行下：
Ctrl + H	删除上一个字符
Ctrl + W	删除上一个单词
Ctrl + V	删除光标所在行
Ctrl + A	快速移动到行首
Ctrl + E	快速移动到行尾


### 在 vim 下：
gi	快速跳转到最后一次编辑的地方，并进行插入模式

### Vim 快速移动：
w/W	移动到下一个 word/WORD 开头
e/E	移动到下一个 word/WORD 结尾
b/B	移动到上一个 word/WORD 开头

**Note**: word 是指以非空白符分割的单词，WORD 是指以空白符为分割的单词

#### 行间的搜索移动：
使用 f{char} 来将光标快速的移动到 char 字符上，t 移动到 char 的前一个字符
如果第一次不是想要定位的字符，可以用分号 ";" 或者 "," 继续搜索该行的下一个/上一个
大写的 F{char} 表示反向来进行搜索 char
例如：想搜索本行中的 "g" 字符，可以使用 "fg" 快速定位到 "g" 这个字符上

#### Vim 的水平移动
0 移动到行首的第一个字符，^ 移动到行首的第一个非空白字符
$ 移动到行尾，g_ 移动到行尾非空白字符
记住常用的 0 和 $ 基本上就可以满足日常需求了

#### Vim 的垂直移动
使用 () 来在句子间进行移动，可以使用 :help ( 来查看帮助文档
使用 {} 来在段落间进行移动
我们可以使用 easy-motion 插件来进行移动，这样这些命令就可以不用记了

#### Vim 页面移动
翻页的命令太多，2/8 定律，记住常见的就能满足需求
gg	移动到文件的开头
G	移动到文件的结尾
Ctrl + o	快速返回
H/M/L	跳转到屏幕的开头(Head)，中间(Middle)，结尾(Lower)
Ctrl + u	向上翻页(upward)
Ctrl + f	向下翻页(forward)
zz	把屏幕置为中间

Vim 的增删改查
x	快速删除一个字符
d	配合文本对象快速删除一个单词 daw(d around word)
d 和 x 都可以搭配数字来执行多次
例: 
	dw	删除一个单词的光标所在字符及其后的单词部分及空白字符，注意，单词的前半部分不删除
	diw	删除一个单词，但不包括其周围的空格
	daw	删除一个单词及其周围的空格，与 dw 一样 
	dt{char}	从当前光标处删除到 {char} 不包括 char 所在字符，但包括光标所在字符
	x	删除光标所在字符
	3x	表示删除光标及其后的总共 3 个字符
	X	删除光标所在字符的前一个字符
	3X	表示删除光标所在字符的前 3 个字符
	dd	删除光标所在行
	3dd	删除光标所在行及其后的总共 3 行
		
Vim 的快速修改
常用的命令有 3 个：r(replace), c(change), s(substitute)
r	替换光标所在字符
R	进行替换模式，一直替换后面的字符
s	删除当前字符并进入插入模式
4s	删除光标所在字符及其后的 3 个字符并进入插入模式
S	将光标所在行内容删除并进入插入模式
4S	删除光标所在行及其后的 3 行并进行插入模式
c	配合文本对象进行快速修改
	例：
	cw	删除光标所在字符及其后的单词部分及空白字符，注意，光标所在的单词的前半部分不删除
	caw	删除光标所在单词及周围空白符，并进入插入模式
	ciw	删除光标所在单词并进入插入模式
	ct{char}	删除至 char 并进入插入模式

C	删除光标所在行并进入插入模式

Vim 查询
/	进行正向搜索
?	进行反向搜索
n	跳转至下一个匹配的对象
N	跳转至上一个匹配的对象
*	匹配当前单词的下一个对象
#	匹配当前单词的上一个对象

补充：
viw	选中一个单词，但不包括周围空格
vaw	选中一个单词，及其周围的空格
vw	选中一个单词的光标所在处到这个词的末尾，及其后的空格  

Vim 如何进行搜索替换(支持正则表达式)	
格式：:[range]s[ubstitute]/{pattern}/{string}/[flags]
range	表示范围 比如：10, 20 表示 10-20 行，% 则表示全部
flags	表示替换位标志
	g(global)	表示全局范围内执行
	c(confirm)	表示确认，可以确认或者拒绝修改
	n(number)	执行匹配到的次数而不替换，可以用来查询匹配次数 例如：":%s/char//n"

Vim 的多文件操作
Buffer	是指打开的一个文件的内存缓冲区
	Buffer - 什么是缓冲区
	vim 打开一个文件之后会加载文件内容到缓冲区，之后的修改都是针对内存中的缓冲区，并不会直接保存到文件，直到我们使用 :w 的时候才会把修改的内容写入到文件中
	如何在 Buffer 之间进行切换：
	使用 :ls 会列举当前缓冲区，然后使用 :b n 跳转到第 n 个缓冲区
	:bpre	跳转到上一个缓冲区
	:bnext	跳转到下一个缓冲区
	:bfirst	跳转到第一个缓冲区
	:blast	跳转到最后一个缓冲区
	:b buffer_name 加上 tab 来进行补全，跳转到指定名字的 Buffer
Window	是 Buffer 的可视化的分割区域
	一个缓冲区可以分割成多个窗口，每个窗口也可以打开不同的缓冲区

Tab	可以组织窗口为一个工作区





window 可视化的分割区域
一个缓冲区可以分割成多个窗口，每个窗口也可以打开不同的缓冲区
<ctrl+w>s	水平分割
<ctrl+w>v	垂直分割
或者：
:sp	水平分割 例如：:sp a.txt 在水平分割窗口的同时打开 a.txt 文件
:vs	垂直分割

窗口之间的切换：
<ctrl + w> + w	在窗口之间循环切换
<ctrl + w> + h	切换到左边的窗口
<ctrl + w> + j	切换到下边的窗口
<ctrl + w> + k	切换到上边的窗口
<ctrl + w> + l	切换到右边的窗口

<ctrl + w> + h	将当前窗口移到左侧
<ctrl + w> + l	将当前窗口移到右侧
<ctrl + w> + h	将当前窗口移到上方
<ctrl + w> + j	将当前窗口移到下方 

如何重排窗口：
使用 :h window-resize 来查看帮助文档
<ctrl + w> + =	使所有的窗口等宽、等高
<ctrl + w> + _	最大化活动窗口的高度
<ctrl + w> + |	最大化活动窗口的宽度
[n]<ctrl + w> + _	把活动窗口的高度设为 [n] 行，例如：20<ctrl + w> + _ 即把活动窗口高度设为 20 行
[n]<ctrl + w> + |	把活动窗口的宽度设为 [n] 列，例如：20<ctrl + w> + | 即把活动窗口宽度设为 20 列

tab(标签页)将窗口进行分组(使用不多，简单了解一下即可)
:tabe[dit] {filename}	在新标签页中打开文件
<ctrl + w> + t	把当前窗口移到下一个新的标签页
:tabc[lose]	关闭当前标签页及其中的所有窗口
:tabo[nly]	只保留活动标签页，关闭所有其他标签页

tab 的切换操作：一般建立两个标签页就可以，不用建立太多
ex 命令		普通模式命令	用途
:tabn[ext] {n}	{n}gt		切换到编号为 n 的标签页
:tabn[ext]	gt		切换到下一个标签页
:tabp[revious]	gt		切换到上一个标签页


vim 的 text object
文本对象的操作方式：
[number]<command>[text object]
number	表示次数
command	表示命令：d(elete), c(hange), y(ank)
text object	要操作的文本对象，比如单词 w, 句子 s，段落 p

示例：
	vi"	选择 "" 中的文本，但不选中双引号
	va"	选择 "" 及其包含的文本
	di}	删除 {} 中的文本，但不删除 {}
	da}	删除 {} 及其包含的文本
	3dw	删除 3 个单词

Vim 中的复制粘贴与寄存器的使用
normal 模式下：
y	复制
p	粘贴
d	剪切
我们可以使用 v 命令来进行选择要复制的内容，然后 y，然后再 p
配合文本对象来进行操作: 比如：
yiw	复制一个单词
yy	复制一行

在我们设置了 autoindent 时候再进行有缩进的复制的时候，我们需要：
先 :set paste
然后粘贴
最后 :set nopaste

## 什么是 Vim 的寄存器？
Vim 里操作的是寄存器而不是系统剪贴板，这和其他编辑器是不同的
默认我们使用 d 删除或者 y 复制的内容都放到了 "无名寄存器" 中

### 深入寄存器(register)
Vim 不是使用单一的寄存器来进行剪切、粘贴、复制，而是使用多组寄存器
我们通过 "{register_name} 前缀可以指定寄存器(即单侧双号加寄存器名称)，不指定则使用默认的寄存器
示例："ayiw 表示复制一个单词到寄存器 a 中，"bdd 删除当前行并放入寄存器 b 中
查看寄存器 a 中的内容 --> :reg a

### 其他常见的寄存器：
复制专用寄存器 "0  -> 使用 y 复制文本的同时会被拷贝到复制寄存器 0
系统剪切板 "+ 可以在复制前加上 "+ 复制到系统剪切板
"%	表示当前文件名的寄存器
".	表示上次插入的文本的寄存器
示例：直接引用系统剪切板上的数据
"+p	直接使用系统剪切板上的数据


### 强大的 Vim 宏(macro)
从需求说起：如果要给多行数据添加相同的操作，此时我们就可以使用宏来操作，例如给 url 批量加双引号
如何使用宏：宏分为录制和回放
Vim 使用 q 来录制，同时也是使用 q 来结束录制
使用 q{register_name} 来选择要保存的寄存器，把录制的命令保存到寄存器中
使用 @{register_name} 来回放寄存器中的保存的一系列的命令
那么如何解决给所有的 url 来加双引号的问题呢？
我们可以先使用 q 开始录制，给一行加上双引号，之后使用 q 退出，最后在剩下的所有行中回放录制的宏
具体操作如下：
1. normal 模式下使用 qa 来开始录制宏到寄存器 a 中
2. 开始对某一个样例行来进行操作
3. 操作结束后，回到 normal 模式下，再按一下 q 退出宏的录制
4. 选中要进行宏操作的行，然后按下 : 键，输入 normal @a 来对所有的行进行批量操作

Note: normal 表示后面要输入的是 normal 模式下的命令
上面的操作，我们也可以用其它方式来完成：
选中要操作的行，然后按下 : 键，输入 normal I" ，这样就在选中行的开头加上了冒号，然后，再按下 : 输入 normal A" 就在选中行的末尾加上了冒号

Vim 中的补全大法
命令			补全类型
<Ctrl + n>		普通关键字
<Ctrl + x><Ctrl + n>	当前缓冲区关键字
<Ctrl + x><Ctrl + i>	包含文件关键字
<Ctrl + x><Ctrl + ]>	标签文件关键字
<Ctrl + x><Ctrl + k>	字典查找
<Ctrl + x><Ctrl + l>	整行补全
<Ctrl + x><Ctrl + f>	文件名补全
<Ctrl + x><Ctrl + o>	全能(0mni)补全

常见了三种补全方式
使用 <Ctrl + n> 和 <Ctrl + p> 补全单词
使用 <Ctrl + x> <Ctrl + f> 补全文件名
使用 <Ctrl + x> <Ctrl + o> 补全代码，需要开启文件类型检查，安装插件


给 Vim 换个颜色
使用 :colorscheme 来显示当前的主题配色，默认是 default
使用 :colorscheme 加空格，再加 <Ctrl + d> 来显示所有的配色方案
使用 :colorscheme 加空格，再加配色名，就可以修改颜色

补充：在两个窗口中打开两个文件
vim a.txt b.txt -O	这样就可以在两个窗口中打开两个文件

补充：打开语法高亮
:syntax on

从网络上下载配色
例如：https://github.com/flazz/vim-colorschemes


Vim 的配置
将常用的设置进行持久化
编辑 ~/.vimrc 文件
直接在文件中写入命令即可，比如 set number, syntax on 等命令，命令前无需加 : 
.vimrc 文件中使用 " 作为注释的标志
------------示例：-----------------
" 设置行号
set nu

" 设置语法高亮
syntax on

" 设置高亮搜索显示
set hlsearch

" 在 insert 模式下，使用 jj 进入 normal 模式
inoremap jj <Esc>

" 使用 <Ctrl> + h/j/k/l 来切换窗口
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l
-----------------------------------

Vim 脚本
Vim 脚本可以实现强大的 Vim 插件
可以通过 vimscript 实现更多的 vim 控制，开发自己的插件

************** Vim 映射 **************

# 基本映射：即 normal 模式下的映射
使用 map 就可以实现映射，比如 :map - x 就可以用 - 来删除字符
例如：:nmap <space> viw 这里按下空格就可以选中整个单词
:map <C-d> dd 就可以使用 Ctrl+d 来删除一行

# Vim 常用模式 normal/visual/insert 都可以定义映射 
用 nmap/vmap/imap 定义映射只在 normal/visual/insert 中分别有效
比如在 insert 模式下使用 Ctrl+d 来删除一行的内容：
:imap <C-d> <Esc>ddO

## nnoremap/vnoremap/inoremap 分别代表各种模式下的非递归映射：即 no recursive map
！！！任何时候都应该使用非递归映射！！！

